<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Bridging the Gap in Joint Speech-Language Training - Introducing ComSL | Atishay Jain</title> <meta name="author" content="Atishay Jain"> <meta name="description" content="CS753 (ASR) Spring'24 Blogger Role"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/letter-a.png?e633e8fed3817b73400ccd2c03d6f771"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://atishay25.github.io/blog/2024/comsl/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Atishay Jain</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="nav-item "> <a class="nav-link" href="/hobbies/">Hobbies</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Bridging the Gap in Joint Speech-Language Training - Introducing ComSL</h1> <p class="post-meta">April 20, 2024</p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/asr"> <i class="fa-solid fa-hashtag fa-sm"></i> ASR</a>   <a href="/blog/tag/speech-translation"> <i class="fa-solid fa-hashtag fa-sm"></i> speech_translation</a>   <a href="/blog/tag/cml"> <i class="fa-solid fa-hashtag fa-sm"></i> CML</a>   <a href="/blog/tag/multi-task-learning"> <i class="fa-solid fa-hashtag fa-sm"></i> multi-task_learning</a>     ·   <a href="/blog/category/asr"> <i class="fa-solid fa-tag fa-sm"></i> ASR</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>In the realm of speech &amp; language in machine learning, we often come across spoken language tasks like Speech translation, summarization, understanding etc. In recent years, an end-to-end (E2E) modeling approach has been widely applied to such tasks, where a single model is trained using E2E optimizations with task-oriented metrics. Conventional approaches employing separate speech and language models have faced several challenges such as scarcity of training data, high GPU computation, and effect of modality gap between speech &amp; language (a significant one). To overcome these problems, a groundbreaking solution has emerged <img class="emoji" title=":fire:" alt=":fire:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png" height="20" width="20"> -</p> <p><img src="https://hackmd.io/_uploads/BJ-1dv-bR.png" alt="ComSL : A Composite Speech-Language Model for End-to-End Speech-to-Text Translation"></p> <p>In this blog, we delve into solving &amp; understanding the above mentioned problems faced in joint speech-language training, as well as explore the promising ideas presented by ComSL to revolutionize the field.</p> <blockquote> <p>First of all, why do these challenges emerge and how do they post a big problem?</p> </blockquote> <p>A conventional E2E model pipeline design generally consists of 2 modules :</p> <pre><code class="language-mermaid">graph TD;
E2E_Model--&gt;Speech_Module;
E2E_Model--&gt;Language_Module;
Speech_Module--&gt;id1(decodes input speech into text);
Language_Module--&gt;id2(infers recognized text to target language or intent);
</code></pre> <p>These 2 modules are trained using their own respective criteria, which may not be optimal for each other. Therefore, the <em>cascaded</em> process may propagate errors that might have occured in a current module to the one following it. Also, since other information like prosodic features are contained in the speech, it becomes difficult to quantize them using language symbols, however they can be beneficial for spoken language tasks.</p> <blockquote> <p>So that’s how the modality gap between the modules is a challenge. What about the other ones?</p> </blockquote> <p>Although unified speech language pretraining based on Transformer architecture has largely boosted E2E modeling for spoken language tasks. In such models, pretraining is conducted jointly on unlabeled speech, unlabeled text, paired speech-to-text and paired text-to-text in multiple languages using both supervised and self-supervised learning. The unified representation from both modalities are simultaneously learned via shared model parameters or auxiliary modality matching losses in pretraining stage. But, as pretrained speech-only and language-only models are becoming increasing powerful, to achieve a comparable performance with such a cascaded module system, unified speech-language pretraining must leverage same or larger scale of data used in only models, which makes training very challenging, because such large amount of required data is not easy to get :(</p> <blockquote> <p>Lack of GPU resources and time is always a problem, you know, we realized this when doing ASR assignments :)</p> </blockquote> <h3 id="comsl-enters-the-chat">ComSL enters the chat</h3> <p>With an innovative blend of transfer learning and cross-modality learning, ComSL streamlines the joint training of speech and language through a multi-task learning framework -</p> <ul> <li>It fully leverages existing pretrained models, no need for pretraining with large data from scratch, directly fine-tune it for downstream tasks, hence data efficient</li> <li>Conventional approaches use contrastive learning among modalities, which require external or internal aligners to force-align speech &amp; text at token/word level. But ComSL’s cross-modality learning with speech-text mapping/matching on either representations is only based on concatenation of paired speech &amp; text. This simplifies implementation and allows it to be incorporated in fine-tuning stage</li> <li>Includes comprehensive ablation study on bridging gap of speech &amp; languages and comparisons with previous works</li> <li>The model outperforms SOTA Google USM, OpenAI whisper ad cascaded non-E2E models by 0.8, 1.8, 1.0 average BLEU score improvements on CoVoST2 evaluation set respectively</li> </ul> <h2 id="the-comsl-model">The ComSL Model</h2> <h3 id="problem-formulation">Problem Formulation</h3> <p>As we have seen now, the goal of E2E Speech Translation (ST) is to directly translate speech from a source language ($L_1$) into text in a target language ($L_2$), without generating an intermediate ASR transcription. Formally, we have to find the most likely sequence $y = {y_1, y_2, \ldots , y_N}$ (eg. words or characters) of length $N$ in $L_2$ given acoustic features $s = {s_1, s_2, \ldots , s_T}$ (eg. Mel Filter Bank features) of length $T$ in $L_1$. A Speech Translation (ST) corpus $D^{ST} = {(s, x, y)}$ generally contains $x = {x_1, x_2, \ldots , x_M}$ (i.e. the transcription of speech in source language), in addition to $y$ and $s$. This allows to use Machine Translation (MT) and ASR as auxiliary tasks in a <strong>Multi-Task</strong> learning manner during optimization of E2E ST model, combinging the losses as -</p> \[L = L_{ST} + L_{MT} + L_{ASR}\] <blockquote> <p>What is this Multitasking now &amp; Why? <em>(screwing up several things at once :))</em></p> </blockquote> <p>In machine learning, multi-task learning (MTL) is a powerful tool that allows different tasks to share common knowledge, boosting overall performance. However, in practice, it faces challenges. For instance, while automatic speech recognition (ASR) can enhance speech representations, the strict alignment required between speech and text can hinder tasks with significant differences in word order. Meanwhile, machine translation (MT) tasks can act as guides for speech-to-text tasks, as mapping text to text is generally easier than mapping speech to text. Yet, the mismatch between speech and text modalities may weaken this guidance’s effectiveness. Thus, while MTL holds promise, navigating these complexities is key to maximizing its benefits!</p> <h3 id="model-architecture">Model Architecture</h3> <p align="center"> <img src="https://hackmd.io/_uploads/SkTe8eJZA.png" alt="ComSL" width="600"> </p> <p>Following the previous works by top-class respected researchers, the model is taken to be a composite model mainly composed of 3 components :</p> <ol> <li> <strong>Speech Transformer Blocks</strong> : Encoder which acts as a powerful speech representation extractor, initialized with encoder parameters of <a href="https://github.com/openai/whisper" rel="external nofollow noopener" target="_blank">whisper model</a> <img class="emoji" title=":bulb:" alt=":bulb:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png" height="20" width="20"> which has strong performance on speech-to-text as well as translation tasks</li> <li> <strong>Adapter</strong> : consists of 2 layers, each composed of a feed-forward module and a 1-D convolution layer with 2 stride, achieving 4 times down-sampling for speech encoder outputs in total. Also, the non-linearity of feed-forward module can speed up adaptation of speech representations to be fed into language Transformer blocks</li> <li> <strong>Language Transformer Blocks</strong> : initialized with <a href="https://huggingface.co/docs/transformers/en/model_doc/mbart" rel="external nofollow noopener" target="_blank">mBART model</a>, composed of 12 encoder and 12 decoder layers with model dimension of 1024 on 16 heads. It is pretrained on monolingual data and fine-tuned on paired MT data and thus capable of many-to-many translation. All its parameters are used to enhance the translation capability of ComSL.</li> </ol> <p>Note that, as we told before, that ComSL leverages the existing pre-trained models, all of these components are initialized by some pretrained model except the adapter</p> <h2 id="cross-modality-learningcml-crown">Cross-modality learning (CML) <img class="emoji" title=":crown:" alt=":crown:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f451.png" height="20" width="20"> </h2> <p>CML is a key component of ComSL introduced in the paper. In the previous Loss equation, we can feed speech-only and text-only inputs into the model to learn ST, ASR and MT tasks. But we wanted to ==minimize the gap between speech and text modalities== and so, we introduce CML based on paired speech-text input. The approach used is such that it intrinsically learns cross-modality information during model optimization, which is different from other approaches which rely on external forced-alignment methods to determine word/unit boundaries.</p> <p align="center"> <img src="https://hackmd.io/_uploads/HkQo3OWZA.png" alt="CML" width="600"> </p> <p>CML involves the following steps -</p> <ol> <li> <strong>Speech-Text Concatenation</strong> - For utilizing paired speech-text data, concatenate the speech embedding $e^s$ (from adapter) and text embeddings $e^x$ (from tokenizer) are concatenated and pass them as input to mBART encoder for further processing</li> <li> <strong>Masked Token Prediction (MTP)</strong> - involves randomly masking text tokens in the concatenated input and training the model to predict these masked tokens. The model learns to fill in the missing tokens based on their corresponding speech embeddings, establishing a strong relation between speech and text modalities.</li> <li> <strong>Speech to Text Mapping (STM)</strong> - In this task, the model learns to map the input speech to the target text by conditioning the encoder output hidden state on both the input speech and the masked ground-truth transcription. The goal is to generate accurate representations that align speech and text.</li> <li> <strong>Encoder Representation Matching (ERM)</strong> - To align speech-only representations with the concatenated input, ComSL employs a loss function that encourages the speech-only representation to be closer to the concatenated representation. This loss is applied to the hidden states of the text encoder, bridging the gap between the modalities.</li> <li> <strong>Decoder Distribution Matching (DDM)</strong> - DDM enhances the performance of the speech translation (ST) task by leveraging the output distribution of the machine translation (MT) task. By incorporating MT output into the ST loss, the model benefits from the better performance of MT and improves its translation capabilities.</li> </ol> <p>These cross-modality learning tasks collectively contribute to the overall performance of ComSL by minimizing the gap between speech and text representations. By incorporating these techniques, ComSL achieves remarkable results in end-to-end speech-to-text translation tasks, surpassing state-of-the-art models in terms of accuracy and data efficiency.</p> <blockquote> <p>But, how is the main training done with all of these many things incorporated?</p> </blockquote> <h2 id="training-strategies">Training Strategies</h2> <p>ComSL employs several training strategies and follows a well-defined pipeline to optimize the performance and effectiveness of the model. Here is an overview of the training strategies and pipeline utilized in ComSL:</p> <ul> <li> <strong>Fine-tuning Language Model</strong> - Before the model composition, it is fine-tuned with all paired text training data by integrating the mBART-50 model. As we observed, mBART has a good extension capability so that it can achieve decent performance even on unseen languages by fine-tuning with limited data. On the other hand, since Whisper has been already trained with data in 100 languages, fine-tuning it has less impact on the final performance.</li> <li> <strong>Multi-task Learning</strong> - ComSL utilizes MTL to train not only ST task (main) but also auxiliary tasks (AST and MT). Multiple loss functions are used such as negative log likelihood loss (for ASR), sequence-to-sequence mapping loss (for ST), cross-entropy loss (for MT) and the final loss $L_{total}$ is takes as weighted sum of these losses - \(L_{total} = w_{asr} * L_{ASR} + w_{st} * L_{ST} + w_{mt} * L_{MT} + w_{CML} * L_{CML}\) Multi-task learning allows shared knowledge and information to be effectively utilized among different tasks, enhancing the overall performance.</li> <li> <strong>Regularization on MT Output</strong> - As the language transformer block (mBART-50) were fine-tuned with MT tasks, they can overfit in multi-learning for composite model. So, to prevent overfitting, introduce an additional language model $\theta’$ (fine-tuned mBART-50) and freeze its parameters during training. Also, add a cross-entropy loss to minimize the difference of their output distributions. This operation is similar to that in ST task, i.e., <em>using a better task as a teacher to guide a relatively worse task</em>. This regularization technique ensures the generalization and stability of the MT task within ComSL.</li> <li> <strong>Freezing Speech Encoder</strong> - If you remember, the speech and language transformer blocks are initialized by well-trained speech-only and text-only models, while the adapter is randomly initialized. So, these three components should use different learning rates during the training. For this, <em>freeze</em> the speech encoder at the first few epochs. This retains powerful speech representations during the early stage of fine-tuning when the gradients are unstable. The language component has the regularization on the MT output that plays a similar role.</li> </ul> <blockquote> <p>So, that is how it is done, what was to be done. Let’s see the outcome of all this hardwork -</p> </blockquote> <h2 id="experiments--results">Experiments &amp; Results</h2> <h3 id="datasets">Datasets</h3> <ol> <li> <strong>E2E ST Data</strong> Experiments were conducted on the ==CoVoST2 dataset==, rich in multilingual speech translations. Our focus? The non-English to English translations (X-EN) using around 400 hours of English recordings and 900 hours from 21 other languages.</li> <li> <strong>Pseudo ST Data</strong> To make up for data for low-resource language pairs in CoVoST2, we cleverly integrated unlabeled translations (translated the transcriptions into English) from Mozilla Common Voice dataset using the mBART model, effectively expanding the dataset by approximately 300 hours across 16 languages.</li> </ol> <h3 id="experimental-setup">Experimental Setup</h3> <p>Two versions of model, named <strong>ComSL Medium</strong> and <strong>ComSL Large</strong> are used in experiments. ComSL Medium uses a Whisper medium encoder with 24 layers of Transformer blocks with 1024 hidden dimensions and 16 heads. On the other hand, ComSL Large steps it up with a larger Whisper encoder using 32 layers of Transformer blocks, 1280 hidden dimensions, and 20 heads. Both versions are equipped with a two-layer convolution adapter and initialized with the mBART model, with parameters totaling 0.9 billion for ComSL Medium and 1.3 billion for ComSL Large.</p> <p>Models underwent rigorous training on GPU clusters, trimmed audio recordings, and employed optimization techniques like deepspeed ZeRo and activation checkpointing. During inference, we unleashed beam search with a beam size of 5 and evaluated BLEU scores using sacreBLEU.</p> <h3 id="main-results">Main Results</h3> <p>The main results are shown in Table1. We divide the 21 test languages into three groups: High-resource, Medium-resource, and Low-resource. With average BLEU scores in hand, we then compare and contrast the performance of ComSL Medium and Large against their predecessors, Whisper Medium and Large. With BLEU scores of 29.7 and 30.1, respectively, ==ComSL Medium and Large outshine Whisper Medium and Large==</p> <p>The main factors contributing to this improvement are:</p> <ul> <li>Replacement of the Whisper decoder with mBART</li> <li>The application of our training strategies and losses in training the combined Whisper and mBART models</li> </ul> <p>Both ComSL Medium and ComSL Large (with a BLEU score of 31.5, which is 0.8 higher than USM with 0.7B fewer parameters) outperform USM when pseudo ST data is used. But there’s still a performance dip attributed to ASR errors when compared to employing ground-truth transcription as inputs for MT.</p> <p align="center"> <img src="https://hackmd.io/_uploads/BJzbcgW-0.png" alt="results_table" width="600"> </p> <h3 id="analysis">Analysis</h3> <h4 id="ablation-study-on-training-tasks-losses-and-strategies">Ablation Study on training tasks, losses and strategies</h4> <div> <img src="https://hackmd.io/_uploads/ByO-APZW0.png" alt="drawing" width="310" height="130" style="float:right"> </div> <p>In a series of ablation studies, ComSL Medium’s performance was analyzed. Initially trained only with the Speech-to-Text (ST) loss, it achieved a BLEU score of 26.48. Adding the Machine Translation (MT) task led to a marginal decrease to 26.31, indicating that directly applying MT task doesn’t directly improve performance. Adding more tasks like Distilled Dual Matching (DDM), Automatic Speech Recognition (ASR) and freezing speech encoder parameters early in training, MT regularization, cross modality learning (CML) loss and pseudo ST data improved the results significantly to a BLEU score of 30.77.</p> <h4 id="comparison-across-different-cross-modality-learning-cml-methods">Comparison across different Cross-Modality Learning (CML) methods</h4> <div style="text-align:center"> <img src="https://hackmd.io/_uploads/S1_ZRDb-A.png" alt="drawing" width="280" height="100" style="float:right"> </div> <p>The baseline model is trained with all strategies and tasks except the methods of minimizing modality gap. It’s performance is compared with our CML, previous MML, ConST and WACO methods. Our CML performs best with an average BLEU score of 29.69. MML is a close runner-up but it requires internal alignment at the tokens which makes the training process more expensive.</p> <p><img src="https://hackmd.io/_uploads/HkdZCvWWA.png" alt="image_2024-04-20_22-01-09"></p> <p>Similarity matrices of speech and text representations, give us a further insight into what happens after CML tasks. The model demonstrates strong text and speech representation alignment even without explicit modality gap minimization, likely benefiting from ASR task knowledge. Cross-Modal Learning (CML) enhances this alignment, creating unified representations even for non-speech tokens like punctuation and silence (illustrated by the green box in the figure). This precise encoding of speech information is a unique feature of CML.</p> <h3 id="conclusion">Conclusion</h3> <p>In summary, ComSL provides a transformative solution to the challenges in joint speech-language training, revolutionizing the way we approach spoken language tasks. The aim of bridging the gap between speech and text representations was achieved through cross-modality learning tasks, in addition to other auxiliary tasks like ASR and MT. The composite model outperformed the constituent speech model (Whisper) or cascaded speech and language models (Whisper+mBART). With its state-of-the-art performance, data efficiency, and innovative cross-modality learning, ComSL sets the stage for a new era of advancements in speech and language processing!</p> <h3 id="references">References</h3> <ul> <li>https://arxiv.org/pdf/2305.14838.pdf</li> <li>https://neurips.cc/virtual/2023/poster/72758</li> </ul> </div> </article> </div> </div> <footer class="sticky-bottom mt-5"> <div class="container"> © Copyright 2024 Atishay Jain. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: August 18, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?07b8786bab9b4abe90d10e61f7d12ff7" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>